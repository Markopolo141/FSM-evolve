<html>
<head>
  <meta charset="utf-8">
  <title>Simulation UnitTests</title>
  <link rel="stylesheet" href="http://code.jquery.com/qunit/qunit-1.19.0.css">
</head>
<body>
  <div id="qunit"></div>
  <div id="qunit-fixture"></div>
  <script src="http://code.jquery.com/qunit/qunit-1.19.0.js"></script>
  <script src="Sim.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/2.3.0/math.min.js"></script>
</body>
</html>

<script>

QUnit.assert.almostEqual = function( a, b, msg ) {
    var truth = math.equal(math.round(math.multiply(a, 10000)), math.round(math.multiply(b, 10000)))
    this.push(truth, a, b, msg);
};
__extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

dummySimulation = (function(_super) {
    __extends(dummySimulation, _super);
    function dummySimulation(a, b) {
        this.a = a;
        this.b = b;
        this.index = 1;
    }
    dummySimulation.prototype.iterate = function() {
        return this.index = this.index + 1;
    };
    dummySimulation.prototype.getQuality = function() {
        return this.a / this.index;
    };
    dummySimulation.prototype.getTrait = function() {
        return this.b / this.index;
    };
    dummySimulation.prototype.getData = function() {
        return this.index;
    };
    return dummySimulation;
})(sim.Simulation);

dummyCountSimulation = (function(_super) {
    __extends(dummyCountSimulation, _super);
    function dummyCountSimulation(a, b, c, d) {
        this.a = a;
        this.b = b;
        this.c = c;
        this.d = d;
        this.index = 1;
    }
    dummyCountSimulation.prototype.iterate = function() {
        return this.index = this.index + 1;
    };
    dummyCountSimulation.prototype.getQuality = function() {
        if (this.index < this.a) {
            return this.c;
        } else {
            return 0;
        }
    };
    dummyCountSimulation.prototype.getTrait = function() {
        if (this.index < this.b) {
            return this.d;
        } else {
            return 0;
        }
    };
    dummyCountSimulation.prototype.getData = function() {
        return this.index;
    };
    return dummyCountSimulation;
})(sim.Simulation);



QUnit.test( "Zip", function( assert ) {
    a1 = [1,2.6,3]
    a2 = [6,7,'aa']
    a3 = [[1,6],[2.6,7],[3,'aa']]
    assert.deepEqual(sim.zip(a1,a2), a3)
});
QUnit.test( "Zip_Dict", function( assert ) {
    a1 = [1,2.6,3]
    a2 = [6,7,'aa']
    a3 = {1:6, 2.6:7, 3:'aa'}
    assert.deepEqual(sim.zip_dict(a1,a2), a3)
});
QUnit.test( "Array Multiply", function( assert ) {
    a1 = [3]
    assert.deepEqual(sim.array_multiply(a1, 3), [3,3,3])
    a1 = [[3,2]]
    assert.deepEqual(sim.array_multiply(a1, 3), [[3,2],[3,2],[3,2]])
    a1 = ["hello"]
    assert.deepEqual(sim.array_multiply(a1, 3), ["hello","hello","hello"])
    a1 = []
    assert.deepEqual(sim.array_multiply(a1, 5), [])
    a1 = ["hello"]
    assert.deepEqual(sim.array_multiply(a1, 0), [])
});
QUnit.test( "Identity Function", function( assert ) {
    a = [1,5,3,9.5,"h3ll",0,function () {return 3}]
    for (var i = 0; i < a.length; i++) {
        assert.deepEqual(sim.identity_function(a[i]), a[i])
    }
});
QUnit.test( "Abs Sum", function( assert ) {
    A = [-1,1,1,-1,55]
    assert.equal(sim.abs_sum(A), 59)
    A = math.matrix(sim.array_multiply([[1]], 5))
    assert.equal(sim.abs_sum(A), 5)
    assert.equal(sim.abs_sum([]), 0)
});
QUnit.test( "Delta", function( assert ) {
    A = [-3,-2,-1,-0.2,0,0.1,1,2,3]
    B = [ 0, 0, 0, 0  ,1,  0,0,0,0]
    for (var i = 0; i < 9; i++) {
        assert.equal(sim.delta(A[i]), B[i])
    }
});
QUnit.test( "Displace", function( assert ) {
    A = [1,2,3,4, -1,-2,-3,-4,]
    B = [4,3,2, -4,-3,-2, 4,3,2]
    C = [0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0]
    D = [1.0, 2.1, 2.8, 1.6, -1.8, -2.0, 1.2, 0.9]
    for (var i = 0; i < A.length; i++) {
        assert.almostEqual(sim.displace(A[i], B[i], C[i]), D[i])
    }
    A = math.matrix(sim.array_multiply([[1]], 5))
    B = math.matrix(sim.array_multiply([[2]], 5))
    C = math.matrix(sim.array_multiply([[1.2]], 5))
    assert.almostEqual(sim.displace(A,B,0.2), C)
});
QUnit.test( "Manhattan Distance", function( assert ) {
    A = [[0,1,2,3,4], [0,-1,-2,-3,-4]]
    B = [[1,2,3,4,5], [-3,-2,-1,0,1]]
    aa = []
    bb = []
    for (var i = 0; i < A.length; i++) {
        aa.push(math.transpose(math.matrix([A[i]])))
        bb.push(math.transpose(math.matrix([B[i]])))
    }
    C = [5, 13]
    for (var i = 0; i < A.length; i++) {
        assert.equal(sim.manhattan_distance(A[i], B[i]), C[i])
        assert.equal(sim.manhattan_distance(aa[i], bb[i]), C[i])
    }
});
QUnit.test( "Manhattan Normalize", function( assert ) {
    A = [[0,1,2,3,4], [0,-1,-2,-3,-4],[1,2,3,4,5], [-3,-2,-1,0,1]]
    C = [[0, 0.1, 0.2, 0.3, 0.4], [0, 0.1, 0.2, 0.3, 0.4], [1.0/15, 2.0/15, 3.0/15, 4.0/15, 5.0/15], [0.6, 0.4, 0.2, -0.0, -0.2]]
    for (var i = 0; i < 4; i++) {
        assert.almostEqual(sim.manhattan_normalize(A[i]), C[i])
        assert.almostEqual(sim.manhattan_normalize(math.transpose(math.matrix([A[i]]))), math.transpose(math.matrix([C[i]])) )
    }
});
QUnit.test( "Generate Even Vector", function( assert ) {
    for (var i = 3; i < 7; i++) {
        v = sim.generate_even_vector(i)
        v.forEach( function(a) {
            assert.almostEqual(a, 1.0/i)
        })
    }
});
QUnit.test( "Generate Constant Vector", function( assert ) {
    for (var i = 3; i < 7; i++) {
        for (var o = 3; o < 7; o++) {
            v = sim.generate_constant_vector(i,o)
            v.forEach(function(z) {
                assert.equal(z,o)
            })
        }
    }
});
QUnit.test( "Matrix Len", function( assert ) {
    for (var r = 2; r < 5; r++) {
        for (var c = 2; c < 5; c++) {
            A = math.matrix(math.zeros([c,r]))
            assert.equal(sim.matrix_len(A), r*c)
        }
    }
});
QUnit.test( "Get Max Index", function( assert ) {
    A = [[0,1,2,3,4,3,2,1,0],
         [4,3,45,76,2,34,2],
         [],
         [99, Infinity,-Infinity,0]]
    B = [4,3,undefined,1]
    for (var i = 0; i < A.length; i++) {
        assert.equal(sim.get_max_index(A[i]), B[i])
    }
});
QUnit.test( "Get Max Of", function( assert ) {
    A = [[0,1,2,3,4,3,2,1,0],
         [4,3,45,76,2,34,2],
         [],
         [99, Infinity,-Infinity,0]]
    B = [4,76,undefined,Infinity]
    for (var i = 0; i < A.length; i++) {
        assert.equal(sim.get_max_of(A[i]), B[i])
    }
});
QUnit.test( "Is Ergodic", function( assert ) {
    m = math.matrix([[1,2],[2,3]])
    assert.equal(sim.is_ergodic(m), true)
    m = math.matrix([[1],[2]])
    assert.equal(sim.is_ergodic(m), false)
    m = math.matrix([[1,0],[0,0]])
    assert.equal(sim.is_ergodic(m), false)
    m = math.matrix([[1,0,0],[0,1,1],[0,1,1]])
    assert.equal(sim.is_ergodic(m), false)
    m = math.matrix([[0,1,0],[0,0,1],[1,0,0]])
    assert.equal(sim.is_ergodic(m), true)
    m = math.matrix([[0,1,0,0],[0,0,1,0],[0,0,0,1],[1,0,0,0]])
    assert.equal(sim.is_ergodic(m), true)
    m = math.matrix([['x+1','x-x'],['x','x*x']])
    assert.equal(sim.is_ergodic(m), false)
    m = math.matrix([[0,'x',0,0],[0,0,'x','x'],['x',0,0,1],[1,0,0,0]])
    assert.equal(sim.is_ergodic(m), true)
    m = math.matrix([['x*x','x-x'],[0,0]])
    assert.equal(sim.is_ergodic(m), false)
});
QUnit.test( "Get Symbols", function( assert ) {
    assert.deepEqual(sim.get_symbols(math.parse('x+z+q')), ['x','z','q'])
    assert.deepEqual(sim.get_symbols(math.parse('44')), [])
    assert.deepEqual(sim.get_symbols(math.parse('x*x-ee')), ['x','ee'])
    assert.deepEqual(sim.get_symbols(math.parse('w*q')), ['w','q'])
});
QUnit.test( "Is Expression With", function( assert ) {
    assert.equal(sim.is_expression_with(math.parse('x+y*y+22'), ['x','y']), true)
    assert.equal(sim.is_expression_with(math.parse('x+y'), ['x','y','z']), true)
    assert.equal(sim.is_expression_with(math.parse('(x*x+y)*2'), ['y','z']), false)
});
QUnit.test( "Matrix Is Expressions With", function( assert ) {
    m = math.matrix([['x*x','y+1'],['1','z-z']])
    assert.equal(sim.matrix_is_expressions_with(m, ['x','y']), false)
    assert.equal(sim.matrix_is_expressions_with(m, ['x','y','z']), true)
    assert.equal(sim.matrix_is_expressions_with(m, ['x']), false)
    assert.equal(sim.matrix_is_expressions_with(m, ['y','z']), false)
});
QUnit.test( "Expression Positive Semi Definite", function( assert ) {
    assert.equal(sim.check_expression_positive_semi_definite(math.parse('x')), true)
    assert.equal(sim.check_expression_positive_semi_definite(math.parse('x+y')), true)
    assert.equal(sim.check_expression_positive_semi_definite(math.parse('x+y-z')), false)
    assert.equal(sim.check_expression_positive_semi_definite(math.parse('x-x')), true)
    assert.equal(sim.check_expression_positive_semi_definite(math.parse('x-0.5')), false)
    assert.equal(sim.check_expression_positive_semi_definite(math.parse('-y/(z-0.4)')), false)
});
QUnit.test( "Check Matrix Positive Semi Definite", function( assert ) {
    m = math.matrix([['x+y','x'],['1','z-z']])
    assert.equal(sim.check_matrix_positive_semi_definite(m), true)
    m = math.matrix([['x-2*z','z'],['z-z','y*55']])
    assert.equal(sim.check_matrix_positive_semi_definite(m), false)
    m = math.matrix([['z','x*-1*x'],['z','z']])
    assert.equal(sim.check_matrix_positive_semi_definite(m), false)
    m = math.matrix([['z','x*x'],['z/y','z']])
    assert.equal(sim.check_matrix_positive_semi_definite(m), true)
    m = math.matrix([['z','x*x'],['y','(z-0.5)*(y-0.5)']])
    assert.equal(sim.check_matrix_positive_semi_definite(m), false)
    m = math.matrix([['z','x*x'],['y/(z-0.4)','z*y']])
    assert.equal(sim.check_matrix_positive_semi_definite(m), false)
    m = math.matrix([['z','x*x'],['-y/(z-0.4)','z*y']])
    assert.equal(sim.check_matrix_positive_semi_definite(m), false)
});
QUnit.test( "Variable Translate", function( assert ) {
    get_rand_seq = function() {
        a = []
        for (var i = 0; i < 3+math.randomInt(3); i++) {
            a = a.concat([math.random()])
        }
        return a
    }
    for (var o = 0; o < 7; o++) {
        a = get_rand_seq()
        b = sim.variable_translate(a)
        assert.equal(b.length, a.length+1)
        assert.almostEqual(math.sum(b), 1.0)
        for (var i = 0; i < a.length; i++) {
            assert.almostEqual(b[i+1]/(b[i]+b[i+1]),a[i])
        }
    }
    for (var o = 0; o < 7; o++) {
        a = math.transpose(math.matrix([get_rand_seq()]))
        b = sim.variable_translate(a)
        assert.equal(b.length, sim.matrix_len(a)+1)
        assert.almostEqual(math.sum(b), 1.0)
        for (var i = 0; i < a.length; i++) {
            assert.almostEqual(b[i+1]/(b[i]+b[i+1]),a[i][0])
        }
    }
    assert.almostEqual(sim.variable_translate([0.5,0.5,0.5]), [0.25,0.25,0.25,0.25])
});
QUnit.test( "Distributed Variable Translate", function( assert ) {
    get_rand_seq = function () {
        f = []
        for (var i = 0; i < 3+math.randomInt(3); i++) {
            f = f.concat([math.randomInt(3)])
        }
        return f
    }
    get_rand_rand_seq = function (l) {
        d = []
        for (var i = 0; i < l; i++) {
            d = d.concat(math.random())
        }
        return d
    }
    for (var i = 0; i < 8; i++) {
        var a = get_rand_seq()
        var b = get_rand_rand_seq(math.sum(a))
        var c = sim.distributed_variable_translate(a,b)
        for (var o = 0; o < c.length; o++) {
            z = c[o]
            if (z != undefined) {
                assert.almostEqual(math.sum(z), 1.0)
            }
        }
        d = 0
        for (var o = 0; o < c.length; o++) {
            z = c[o]
            if (z != undefined) {
                assert.almostEqual(sim.variable_translate(b.slice(d,d+z.length-1)), z)
                d = d + z.length-1
            }
        }
    }
    Z = sim.distributed_variable_translate([0,1,2,3,1], sim.array_multiply([0.5], 7))
    Y = [undefined,[0.5,0.5],[1.0/3,1.0/3,1.0/3],[0.25,0.25,0.25,0.25],[0.5,0.5]]
    for (var i = 0; i < Z.length; i++) {
        assert.deepEqual(Z[i], Y[i])
    }
});
QUnit.test( "Get Distribution", function( assert ) {
    lower = 2
    upper = 5
    for (var i = 0; i < 5; i++) {
        r = math.randomInt(lower,upper)
        c = math.randomInt(lower,upper)
        m = math.zeros(r,c)
        for (var z = 0; z < math.randomInt(2,lower*upper); z++) {
            m._data[math.randomInt(0,r-1)][math.randomInt(0,c-1)] = 1
        }
        mt = math.transpose(m)
        d = []
        for (var o = 0; o < mt._data.length; o++) {
            z = math.sum(mt._data[o])
            d.push(math.max(0, z-1))
        }
        f = sim.get_distribution(m)
        assert.deepEqual(f,d)
    }
    assert.deepEqual(sim.get_distribution(math.matrix([[1,0],[1,0],[0,1]])), [1,0])
});
QUnit.test( "Weight Choice", function( assert ) {
    exprs = ["s1+1", "s2+1", "s1+s2", "s1*s2", "s2*s3", "s2-s2+2", "s3-s1", "s3+s2*s1", "s1*s1+3", "s3*s2"]
    vals = [math.matrix([[1,2,3,4]]),math.matrix([[4,3,2,1]]),math.matrix([[11,22,33,44]])]
    rands = []
    for (var aa = 0; aa < 5; aa++) {
        r = math.randomInt(2,4)
        c = math.randomInt(2,4)
        for (var i = 0; i < r*c; i++) {
            rands.push(math.random())
        }
        m = math.zeros(r,c)
        for (var ri = 0; ri < r; ri++) {
            for (var ci = 0; ci < c; ci++) {
                m._data[ri][ci] = exprs[math.floor(rands[ri*ci]*exprs.length)]
            }
        }
        for (var z = 0; z < vals.length; z++) {
            mm = sim.weight_choice(m, vals[z])
            for (var ri = 0; ri < r; ri++) {
                for (var ci = 0; ci < c; ci++) {
                    assert.equal(mm._data[ri][ci], math.parse(exprs[math.floor(rands[ri*ci]*exprs.length)]).eval(sim.zip_dict(['s0','s1','s2','s3'], vals[z]._data[0])) )
                }
            }
        }
    }
    assert.almostEqual(sim.weight_choice(math.matrix([['s0+s1','s2+s3'],['s2-s1','s3-s2']]), math.matrix([[1,2,3,4]])), math.matrix([[3,7],[1,1]]))
    assert.almostEqual(sim.weight_choice(math.matrix([['s0+s1','s2+s3'],['s2-s1','s3-s2']]), math.matrix([[1,4,3,4]])), math.matrix([[3,7],[1,1]]))
});
QUnit.test( "Weight Switch", function( assert ) {
    for (var o = 0; o < 30; o++) {
        r = math.randomInt(2,5)
        c = math.randomInt(2,5)
        m = math.zeros(r,c)
        for (var i = 0; i < math.randomInt(2,5*5); i++) {
            m._data[math.randomInt(0,r-1)][math.randomInt(0,c-1)] = 1
        }
        num_vars = math.sum(sim.get_distribution(m))
        v = sim.array_multiply([0.5], num_vars)
        mm = sim.weight_switch(m, v)
        for (var ci = 0; ci < c; ci++) {
            for (var ri = 0; ri < r; ri++) {
                element = mm._data[ri][ci]
                assert.equal(element==0 || element==1.0/math.sum(math.transpose(m)._data[ci]), true)
            }
        }
    }
    assert.almostEqual(sim.weight_switch(math.matrix([[0, 0],[0, 0]]),[]), math.matrix([[0, 0],[0, 0]]))
    assert.almostEqual(sim.weight_switch(math.matrix([[0, 0],[0, 0]]),[1,2,3]), math.matrix([[0, 0],[0, 0]]))
    assert.almostEqual(sim.weight_switch(math.matrix([[1, 0],[0, 1]]),[]), math.matrix([[1, 0],[0, 1]]))
    assert.almostEqual(sim.weight_switch(math.matrix([[1, 0],[1, 1]]),[0.1]), math.matrix([[0.1, 0],[0.9, 1]]))
});
QUnit.test( "Sim 1", function( assert ) {
    Sim = sim.SubPopulationGrowthSimulation
    s = new Sim(math.matrix([[1,0],[0,1]]), math.matrix([[0,1],[1,0]]), {"smoothing_factor":0.5})
    m = s.population
    s.iterate()
    t = s.getTrait()
    for (var i = 0; i < 15; i++) {
        assert.almostEqual(s.population, m)
        assert.almostEqual(s.getData(), m)
        assert.equal(s.getQuality(), 0.0)
        assert.equal(s.getTrait(), t)
        s.iterate()
    }
    assert.equal(t, 1.0)
});
QUnit.test( "Sim 2", function( assert ) {
    Sim = sim.SubPopulationGrowthSimulation
    s = new Sim(math.matrix([[0.5,0],[0,0.5]]), math.matrix([[0,1],[1,0]]), {"smoothing_factor":0.5})
    m = s.population
    s.iterate()
    t = s.getTrait()
    for (var i = 0; i < 15; i++) {
        assert.almostEqual(s.population, m)
        assert.almostEqual(s.getData(), m)
        assert.equal(s.getQuality(), 0.0)
        assert.equal(s.getTrait(), t)
        s.iterate()
    }
    assert.equal(t, 0.75)
});
QUnit.test( "Sim 3", function( assert ) {
    Sim = sim.SubPopulationGrowthSimulation
    s = new Sim(math.matrix([[0.5,0,0.5],[0.2,0,0.5],[0.5,0.4,0.3]]), math.matrix([[0,1,1],[1,0,1],[1,1,0]]), {"smoothing_factor":0.5})
    s.iterate()
    q = s.getQuality()
    t = s.getTrait()
    for (var i = 0; i < 35; i++) {
        assert.equal(s.getQuality()<=q, true)
        q = s.getQuality()
        s.iterate()
    }
});
QUnit.test( "Simulate", function( assert ) {
    params = [[50,20],[10,140],[40,20],[10,12],[2,340],[3,1239]]
    its = [5,13,5,4,19,36]
    its2 = [50,10,40,10,3,3]
    for (var i = 0; i < params.length; i++) {
        p = params[i]
        s = new dummySimulation(p[0], p[1])
        s.simulate(1000.0,1.0)
        assert.equal(s.index, its[i])
    }
    for (var i = 0; i < params.length; i++) {
        p = params[i]
        s = new dummySimulation(p[0], p[1])
        s.simulate(1.0,10000.0)
        assert.equal(s.index, its2[i])
    }
});
QUnit.test( "Ensemble Simulate", function( assert ) {
    for (var z = 0; z < math.randomInt(10,35); z++) {
        aes = []
        bes = []
        des = []
        for (var i = 0; i < math.randomInt(5,15); i++) {
            aes.push(math.randomInt(20,50))
            bes.push(math.randomInt(20,50))
            des.push(math.random()*10.0)
        }
        total_sims = []
        for (var i = 0; i < aes.length; i++) {
            total_sims.push(new dummyCountSimulation(aes[i],bes[i],10.0,des[i]))
        }
        Sim = sim.SimpleEnsembleSimulation
        sims = new Sim(total_sims)
        sims.simulate(1.0)
        for (var i = 0; i < math.max(math.max(aes),math.max(bes)); i++) {
            Z = []
            for (var o = 0; o < aes.length; o++) {
                if (i < bes[o]) {
                    Z.push(des[o])
                } else {
                    Z.push(0.0)
                }
            }
            indexo = sim.get_max_index(Z)
            if (i >= aes[indexo]) {
                assert.equal(sims.sims[0].index, i)
                break
            }
        }
    }
});
QUnit.test( "Greatest Ascent Simulation", function( assert ) {
    Sim = sim.GreatestAscentSimulation
    simulation = new Sim(
        0.0,
        function (x) {return [x-1,x+1]},
        function (a,b,c,d) {return undefined},
        function (x,y) {
            ret = []
            for (var i = 0; i < x.length; i++) {
                a = x[i]
                ret.push(-(5-a)*(5-a))
            }
            return ret
        },
        function (x) {return x},
        function (x,y) {return y},
        function (x,y) {return math.abs(math.subtract(x,y))}
    )
    simulation.simulate(0.0)
    assert.equal(simulation.newer, 5.0)
});
QUnit.test( "Greatest Ascent Simulatable", function( assert ) {
    Sim = sim.GreatestAscentSimulation
    simulation = new Sim(
        0.0,
        function (x) {return [x-1,x+1]},
        function (a,b,c,d) {return undefined},
        function (x,y) {
            ret = []
            for (var i = 0; i < x.length; i++) {
                a = x[i]
                ret.push(-(5-a)*(5-a))
            }
            return ret
        },
        function (x) {return x},
        function (x,y) {return 0.5*x+0.5*y},
        function (x,y) {return math.abs(math.subtract(x,y))}
    )
    simulation.simulate(0.0)
    assert.equal(simulation.newer, 4.5)
});
QUnit.test( "Reduction Simulation", function( assert ) {
    Sim = sim.GreatestAscentSimulation
    RedSim = sim.ReductionSimulation
    simulation = new Sim(
        0.0,
        function (x) {return [x-1,x+1]},
        function (a,b,c,d) {return undefined},
        function (x,y) {
            ret = []
            for (var i = 0; i < x.length; i++) {
                a = x[i]
                ret.push(-(5-a)*(5-a))
            }
            return ret
        },
        function (x) {return x},
        function (x,y) {return 0.5*x+0.5*y},
        function (x,y) {return math.abs(math.subtract(x,y))}
    )
    red_sim = new RedSim(
        simulation,
        function (sim,r) {
            sim.generator = function(x) {return [x-r,x+r]}
        },
        5,
        0.1,
        {"target_quality":0.001}
    )
    red_sim.simulate(0.0001, repeated=0)
    assert.almostEqual(red_sim.simulation.newer, 5)
});
</script>
